C51 COMPILER V9.00   W25QXX                                                                06/18/2015 16:30:44 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE W25QXX
OBJECT MODULE PLACED IN .\Object\W25Qxx.obj
COMPILER INVOKED BY: d:\Keil\C51\BIN\C51.EXE user\W25Qxx\W25Qxx.c LARGE BROWSE INCDIR(.\user\LCD;.\user\W25Qxx;.\user;.\
                    -user\TOUCH;.\user\flash;.\user\ds1302;.\user\timer;.\user\GUI;.\user\ds18b20;.\user\uart) DEBUG OBJECTEXTEND PRINT(.\Lst
                    -\W25Qxx.lst) OBJECT(.\Object\W25Qxx.obj)

line level    source

   1          /******************************************************************
   2          **此字库芯片包含的字库为GBK和ASCII；
   3          **需要字库芯片可进店铺：http://shop105602061.taobao.com/
   4          **技术交流请联系QQ：765109842
   5          *******************************************************************/
   6          
   7          #include "w25qxx.h" 
   8          #include "ds1302.h"
   9          
  10          u16 W25Qxx_TYPE = W25Q64;       //定义使用的flash芯片型号
  11          
  12          _font_info code ftinfo = //数字为字库在FLASH里的地址，不能修改！！！
  13          {
  14                  170,102476,570,103046,574560,677606,1140,678746,766080,1444826,1520,
  15                  1446346,1723680,3170026,420,3173446,3064320,6237766,6080
  16          };
  17          
  18          
  19          //函数声明(模块内使用)
  20          void W25Qxx_Init(void);                 //W25Qxx初始化（IO口） 
  21          u8       W25Qxx_Read_Byte(void);                        //从W25Qxx读一个字节
  22          void W25Qxx_Write_Byte(u8 value);       //向W25Qxx写一个字节
  23          u16  W25Qxx_ReadID(void);           //读取FLASH ID
  24          void W25Qxx_Read(u8* pBuffer,u32 ReadAddr,u16 NumByteToRead);   //读取flash
  25          void Get_HzMat(u8 *gbcode,u8 *mat,u8 gbsize);   //得到汉字的点阵码（数组）
  26          void Show_ASCII(u16 x,u16 y,u8 num,u8 gbsize,u16 p_color,u16 b_color);  //在指定位置显示一个字符
  27          void Show_Font(u16 x,u16 y,u8 *font,u8 gbsize,u16 p_color,u16 b_color); //在指定位置显示一个汉字
  28          
  29          
  30          /****************************************************************************
  31          **函数功能：向W25Qxx写入一个字节（先写入高位）
  32          **函数参数：value需写入的数据
  33          ****************************************************************************/
  34          void W25Qxx_Write_Byte(u8 value)
  35          { 
  36   1         u8 i;
  37   1         for(i=0; i<8; i++)
  38   1         {    
  39   2           if(value & 0x80)
  40   2                W25Qxx_DI = 1;    
  41   2           else 
  42   2                W25Qxx_DI = 0;
  43   2               
  44   2               W25Qxx_CLK = 0;        
  45   2               value <<= 1;
  46   2           W25Qxx_CLK = 1;       
  47   2         }
  48   1      }
  49          
  50          
  51          /****************************************************************************
  52          **函数功能：从W25Qxx读出一个字节（先读出高位）
  53          **返回值：读出的数据
C51 COMPILER V9.00   W25QXX                                                                06/18/2015 16:30:44 PAGE 2   

  54          ****************************************************************************/
  55          u8 W25Qxx_Read_Byte(void)
  56          { 
  57   1         u8 temp=0;
  58   1              u8 tt= 0;
  59   1         u8 i;
  60   1              
  61   1         for(i=0;i<8;i++)    
  62   1         {
  63   2           W25Qxx_CLK=0;         
  64   2           W25Qxx_CLK=1;        
  65   2               tt = W25Qxx_DO;   
  66   2               temp = ((temp << 1) | tt);       
  67   2         }
  68   1         return (temp);
  69   1      }
  70                                     
  71          /**************************************************
  72          **函数功能：读取芯片ID
  73          **返回值：芯片ID
  74          **************************************************/
  75          u16 W25Qxx_ReadID(void)
  76          {
  77   1              u16 Temp = 0;     
  78   1              W25Qxx_CS=0;                                
  79   1              W25Qxx_Write_Byte(0x90);//发送读取ID命令            
  80   1              W25Qxx_Write_Byte(0x00);            
  81   1              W25Qxx_Write_Byte(0x00);            
  82   1              W25Qxx_Write_Byte(0x00);                                   
  83   1              Temp|=W25Qxx_Read_Byte()<<8;  
  84   1              Temp|=W25Qxx_Read_Byte();        
  85   1              W25Qxx_CS=1;                                
  86   1              return Temp;
  87   1      }                   
  88          
  89          
  90          //W25Qxx写禁止  
  91          //将WEL清零  
  92          void W25Qxx_Write_Disable(void)   
  93          {  
  94   1              W25Qxx_CS=0;                            //使能器件   
  95   1          W25Qxx_Write_Byte(W25X_WriteDisable);     //发送写禁止指令    
  96   1              W25Qxx_CS=1;                            //取消片选            
  97   1      } 
  98          
  99          /**************************************************
 100          **函数功能：在指定地址开始读取指定长度的数据
 101          **函数参数：pBuffer:数据存储区
 102                                  ReadAddr:开始读取的地址(24bit)
 103                                  NumByteToRead:要读取的字节数(最大65535)
 104          **************************************************/
 105          void W25Qxx_Read(u8* pBuffer,u32 ReadAddr,u16 NumByteToRead)   
 106          { 
 107   1              u16 i;
 108   1              CE=0;
 109   1              W25Qxx_CS=0;                            //使能器件   
 110   1          W25Qxx_Write_Byte(W25X_ReadData);         //发送读取命令   
 111   1          W25Qxx_Write_Byte((u8)((ReadAddr)>>16));  //发送24bit地址    
 112   1          W25Qxx_Write_Byte((u8)((ReadAddr)>>8));   
 113   1          W25Qxx_Write_Byte((u8)ReadAddr);   
 114   1          for(i=0;i<NumByteToRead;i++)
 115   1              { 
C51 COMPILER V9.00   W25QXX                                                                06/18/2015 16:30:44 PAGE 3   

 116   2              pBuffer[i] = W25Qxx_Read_Byte();   //循环读数  
 117   2          }
 118   1              W25Qxx_CS=1;                            //取消片选            
 119   1      }  
 120          
 121          /**************************************************
 122          **函数功能：初始化字库
 123          **返回值：0：字库完好.  1:字库丢失
 124          **************************************************/
 125          u8 font_init(void)
 126          {                                                                                                                        
 127   1              W25Qxx_Write_Disable(); //禁止写   
 128   1              W25Qxx_TYPE = W25Qxx_ReadID();                  //读取FLASH ID.  
 129   1              if(ftinfo.fontok!=0XAA)return 1;                //字库错误. 
 130   1              W25Qxx_CS=1;
 131   1              return 0;                   
 132   1      }
 133          
 134          
 135          /**************************************************
 136          **函数功能：从字库中查找出字模
 137          **函数参数：code 字符串的开始地址,GBK码,mat:数据存放地址 size :大小      
 138          **************************************************/
 139          void Get_HzMat(unsigned char *gbcode,unsigned char *mat,u8 gbsize)
 140          {                   
 141   1              unsigned char qh,ql;
 142   1              unsigned char i;                                          
 143   1              u32 foffset; 
 144   1              qh=*gbcode;
 145   1              ql=*(++gbcode);
 146   1              if(qh<0x81||ql<0x40||ql==0xff||qh==0xff)//非 常用汉字
 147   1              {  
 148   2                  for(i=0;i<(gbsize*2);i++)   *mat++=0x00;//填充满格
 149   2                  return; //结束访问
 150   2              }          
 151   1              if(ql<0x7f)ql-=0x40;//注意!
 152   1              else ql-=0x41;
 153   1              qh-=0x81;  
 154   1                                        
 155   1              if(gbsize==32)
 156   1              {       
 157   2                      foffset=((unsigned long)190*qh+ql) * 128;//得到字库中的字节偏移量 
 158   2                      W25Qxx_Read(mat,foffset+ftinfo.gbk32addr,128);
 159   2              }
 160   1              else if(gbsize==24)     
 161   1              {
 162   2                      foffset=((unsigned long)190*qh+ql) * 72;//得到字库中的字节偏移量        
 163   2                      W25Qxx_Read(mat,foffset+ftinfo.gbk24addr,72);
 164   2              }
 165   1              else if(gbsize==16)     
 166   1              {
 167   2                      foffset=((unsigned long)190*qh+ql)*32;//得到字库中的字节偏移量          
 168   2                      W25Qxx_Read(mat,foffset+ftinfo.gbk16addr,32);
 169   2              }
 170   1              else if(gbsize==12)     
 171   1              {
 172   2                      foffset=((unsigned long)190*qh+ql)*24;//得到字库中的字节偏移量          
 173   2                      W25Qxx_Read(mat,foffset+ftinfo.gbk12addr,24);  
 174   2              }                       
 175   1      } 
 176          
 177          /**************************************************
C51 COMPILER V9.00   W25QXX                                                                06/18/2015 16:30:44 PAGE 4   

 178          **函数功能：显示一个指定大小的字符
 179          **函数参数：x,y :坐标,num:ASCII码,size:字体大小
 180                                  p_color:点的颜色, b_color：背景颜色      
 181          **************************************************/
 182          void Show_ASCII(u16 x,u16 y,u8 num,u8 gbsize,u16 p_color,u16 b_color)
 183          {                                                         
 184   1          u8 temp,t1,t,max_t;
 185   1              u8 mat[65] = "";
 186   1              u16 y0=y;
 187   1              u32 temp_addr;
 188   1              u32 offset = num - ' ';//得到偏移后的值;
 189   1                         
 190   1              if(gbsize==32)          
 191   1              {
 192   2                      offset *= 64;   
 193   2                      max_t = 64;
 194   2                      temp_addr = ftinfo.asc32addr;
 195   2              }
 196   1              else if(gbsize==24)     
 197   1              {
 198   2                      offset *= 36;   
 199   2                      max_t = 36;
 200   2                      temp_addr = ftinfo.asc24addr;
 201   2              }
 202   1              else if(gbsize==16)     
 203   1              {
 204   2                      offset *= 16;   
 205   2                      max_t = 16;
 206   2                      temp_addr = ftinfo.asc16addr;
 207   2              }
 208   1              else if(gbsize==12)     
 209   1              {
 210   2                      offset *= 12;   
 211   2                      max_t = 12;
 212   2                      temp_addr = ftinfo.asc12addr;
 213   2              }
 214   1              
 215   1              else if(gbsize==8)      
 216   1              {
 217   2                      offset *= 6;    
 218   2                      max_t = 6;
 219   2                      temp_addr = ftinfo.asc68addr;
 220   2              }
 221   1              
 222   1              W25Qxx_Read(mat,offset + temp_addr,max_t);
 223   1              
 224   1              for(t=0;t<max_t;t++)
 225   1              {   
 226   2                      temp=mat[t];  //调用字体数组
 227   2                      for(t1=0;t1<8;t1++)
 228   2                      {               
 229   3                              if(gbsize==8)
 230   3                              {
 231   4                                      if((temp >> t1) & 0x01)
 232   4                                              SHOW_POINT_FUNC(x,y,p_color);//在指定位置打指定颜色的点
 233   4                                      else 
 234   4                                              if(b_color!=Nocolor) if(b_color!=Nocolor) SHOW_POINT_FUNC(x,y,b_color);//在指定位置打指定颜色的点
 235   4                              }       
 236   3                              else
 237   3                              {
 238   4                                      if((temp << t1) & 0x80)
 239   4                                              SHOW_POINT_FUNC(x,y,p_color);//在指定位置打指定颜色的点
C51 COMPILER V9.00   W25QXX                                                                06/18/2015 16:30:44 PAGE 5   

 240   4                                      else 
 241   4                                              if(b_color!=Nocolor) SHOW_POINT_FUNC(x,y,b_color);//在指定位置打指定颜色的点
 242   4                              }
 243   3                              
 244   3                              y++;
 245   3                              if(y >= max_y){return;}//超区域了
 246   3                              
 247   3                              if((y-y0)==gbsize)
 248   3                              {
 249   4                                      y=y0;
 250   4                                      x++;
 251   4                                      if(x >= max_x){return;}//超区域了
 252   4                                      break;
 253   4                              }
 254   3                      }        
 255   2              }                                         
 256   1      }
 257          
 258          
 259          /**************************************************
 260          **函数功能：显示一个指定大小的汉字
 261          **函数参数：x,y :汉字的坐标,font:汉字GBK码,size:字体大小
 262                                          p_color:点的颜色, b_color：背景颜色
 263          **************************************************/
 264          void Show_Font(u16 x,u16 y,u8 *font,u8 gbsize,u16 p_color,u16 b_color)
 265          {
 266   1              u16 temp,t,t1,max_t;
 267   1              u16 y0=y;
 268   1              u8 dzk[256]; 
 269   1              if(gbsize!=12 && gbsize!=16 && gbsize!=24 && gbsize!= 32)
 270   1                      return;//不支持的size
 271   1              
 272   1              Get_HzMat(font,dzk,gbsize);//得到相应大小的点阵数据
 273   1              
 274   1              if(gbsize == 32)      max_t = 128;
 275   1              else if(gbsize == 24) max_t = 72;
 276   1              else                            max_t = gbsize * 2;
 277   1              
 278   1       
 279   1              for(t = 0;t < max_t;t++)
 280   1              {                                                                                                  
 281   2                      temp=dzk[t];                         
 282   2                      for(t1=0;t1<8;t1++)
 283   2                      {
 284   3                              if(temp&0x80)
 285   3                              {
 286   4                                      SHOW_POINT_FUNC(x,y,p_color);//在指定位置打指定颜色的点
 287   4                              }
 288   3                              else 
 289   3                              {
 290   4                                      if(b_color!=Nocolor) SHOW_POINT_FUNC(x,y,b_color);//在指定位置打指定颜色的点
 291   4                              }
 292   3                              
 293   3                              temp<<=1;
 294   3                              y++;
 295   3                              if((y-y0)==gbsize)
 296   3                              {
 297   4                                      y=y0;
 298   4                                      x++;
 299   4                                      break;
 300   4                              }
 301   3                      }        
C51 COMPILER V9.00   W25QXX                                                                06/18/2015 16:30:44 PAGE 6   

 302   2              } 
 303   1      }
 304          
 305          
 306          /*********************************************************************
 307          **函数功能：在指定位置开始显示一个字符串          
 308          **函数参数：(x,y):起始坐标，str  :字符串，size :字体大小，
 309                                  p_color:点的颜色, b_color：背景颜色
 310          **********************************************************************/
 311          void Show_Str(u16 x,u16 y,u8 *str,u8 gbsize,u16 p_color,u16 b_color)
 312          {                                                                         
 313   1          u8 bHz=0;     //字符或者中文        
 314   1          while(*str!=0)//数据未结束
 315   1          { 
 316   2              if(!bHz)
 317   2              {
 318   3                      if(*str > 0x80)
 319   3                                      bHz=1;//中文 
 320   3                      else              //字符
 321   3                      {                               
 322   4                                      if(y > max_y)break;//越界返回 
 323   4                                      Show_ASCII(x,y,*str,gbsize,p_color,b_color);//有效部分写入 
 324   4                                      str++; 
 325   4                                      
 326   4                              if(gbsize == 8)
 327   4                                              x += 6; //字符,为全字的一半 
 328   4                                      else    
 329   4                                              x += gbsize/2; //字符,为全字的一半 
 330   4                                              
 331   4                                      if(x > max_x)//换行
 332   4                                      {       
 333   5                                              str -= 1; 
 334   5                                              y += gbsize;
 335   5                                              x = 0;     
 336   5                                      }
 337   4                      }
 338   3              }
 339   2                      else//中文 
 340   2              {     
 341   3                  bHz=0;//有汉字库 
 342   3      
 343   3                      if(y > max_y)break;//越界返回   
 344   3                              
 345   3                      Show_Font(x,y,str,gbsize,p_color,b_color); //显示这个汉字,空心显示 
 346   3                      str+=2; 
 347   3                      x += gbsize;//下一个汉字偏移
 348   3                              
 349   3                              if(x > max_x)//换行
 350   3                              {       
 351   4                                      str -= 2; 
 352   4                                      y += gbsize;
 353   4                                      x = 0;     
 354   4                              }                       
 355   3              }                                                
 356   2          }   
 357   1      }  
 358          
 359          /*********************************************************************
 360          **函数功能：在指定位置开始显示数字        
 361          **函数参数：(x,y):起始坐标，num :数字，len:数字的位数，size :字体大小，
 362                                  p_color:点的颜色, b_color：背景颜色
 363          **********************************************************************/
C51 COMPILER V9.00   W25QXX                                                                06/18/2015 16:30:44 PAGE 7   

 364          /*void Show_number(u16 x,u16 y,u32 num,u8 len,u8 gbsize,u16 p_color,u16 b_color)
 365          {       
 366                  u8 buf[10] = "";
 367                  u32 t_num = 1;
 368                  u8 i;
 369                  for(i = 0; i < len; i++)
 370                  {
 371                          buf[len - i - 1] = num / t_num % 10 + '0';
 372                          t_num *= 10;
 373                  }
 374                          
 375                  Show_Str(x,y,buf,gbsize,p_color,b_color);
 376                          
 377          }*/
 378          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2346    ----
   CONSTANT SIZE    =    141    ----
   XDATA SIZE       =      2     407
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
