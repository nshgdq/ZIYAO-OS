C51 COMPILER V9.00   W25QXX                                                                07/13/2015 15:35:09 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE W25QXX
OBJECT MODULE PLACED IN .\Object\W25Qxx.obj
COMPILER INVOKED BY: d:\Keil\C51\BIN\C51.EXE user\W25Qxx\W25Qxx.c LARGE BROWSE INCDIR(.\user\Include) DEBUG OBJECTEXTEND
                    - PRINT(.\Lst\W25Qxx.lst) TABS(2) OBJECT(.\Object\W25Qxx.obj)

line level    source

   1          /******************************************************************
   2          **此字库芯片包含的字库为GBK和ASCII；
   3          *******************************************************************/
   4          
   5          #include "w25qxx.h" 
   6          #include "ds1302.h"
   7          
   8          u16 W25Qxx_TYPE = W25Q64; //定义使用的flash芯片型号
   9          
  10          _font_info code ftinfo = //数字为字库在FLASH里的地址，不能修改！！！
  11          {
  12            170,102476,570,103046,574560,677606,1140,678746,766080,1444826,1520,
  13            1446346,1723680,3170026,420,3173446,3064320,6237766,6080
  14          };
  15          
  16          
  17          //函数声明(模块内使用)
  18          void W25Qxx_Init(void);     //W25Qxx初始化（IO口） 
  19          u8   W25Qxx_Read_Byte(void);      //从W25Qxx读一个字节
  20          void W25Qxx_Write_Byte(u8 value); //向W25Qxx写一个字节
  21          u16  W25Qxx_ReadID(void);       //读取FLASH ID
  22          void W25Qxx_Read(u8* pBuffer,u32 ReadAddr,u16 NumByteToRead);   //读取flash
  23          void Get_HzMat(u8 *gbcode,u8 *mat,u8 gbsize); //得到汉字的点阵码（数组）
  24          void Show_ASCII(u16 x,u16 y,u8 num,u8 gbsize,u16 p_color,u16 b_color);  //在指定位置显示一个字符
  25          void Show_Font(u16 x,u16 y,u8 *font,u8 gbsize,u16 p_color,u16 b_color); //在指定位置显示一个汉字
  26          
  27          
  28          /****************************************************************************
  29          **函数功能：向W25Qxx写入一个字节（先写入高位）
  30          **函数参数：value需写入的数据
  31          ****************************************************************************/
  32          void W25Qxx_Write_Byte(u8 value)
  33          { 
  34   1         u8 i;
  35   1         for(i=0; i<8; i++)
  36   1         {    
  37   2           if(value & 0x80)
  38   2          W25Qxx_DI = 1;    
  39   2           else 
  40   2          W25Qxx_DI = 0;
  41   2         
  42   2         W25Qxx_CLK = 0;        
  43   2         value <<= 1;
  44   2           W25Qxx_CLK = 1;       
  45   2         }
  46   1      }
  47          
  48          
  49          /****************************************************************************
  50          **函数功能：从W25Qxx读出一个字节（先读出高位）
  51          **返回值：读出的数据
  52          ****************************************************************************/
  53          u8 W25Qxx_Read_Byte(void)
  54          { 
C51 COMPILER V9.00   W25QXX                                                                07/13/2015 15:35:09 PAGE 2   

  55   1         u8 temp=0;
  56   1        u8 tt= 0;
  57   1         u8 i;
  58   1        
  59   1         for(i=0;i<8;i++)    
  60   1         {
  61   2           W25Qxx_CLK=0;         
  62   2           W25Qxx_CLK=1;        
  63   2         tt = W25Qxx_DO;   
  64   2         temp = ((temp << 1) | tt);     
  65   2         }
  66   1         return (temp);
  67   1      }
  68                   
  69          /**************************************************
  70          **函数功能：读取芯片ID
  71          **返回值：芯片ID
  72          **************************************************/
  73          u16 W25Qxx_ReadID(void)
  74          {
  75   1        u16 Temp = 0;   
  76   1        W25Qxx_CS=0;            
  77   1        W25Qxx_Write_Byte(0x90);//发送读取ID命令      
  78   1        W25Qxx_Write_Byte(0x00);      
  79   1        W25Qxx_Write_Byte(0x00);      
  80   1        W25Qxx_Write_Byte(0x00);           
  81   1        Temp|=W25Qxx_Read_Byte()<<8;  
  82   1        Temp|=W25Qxx_Read_Byte();  
  83   1        W25Qxx_CS=1;            
  84   1        return Temp;
  85   1      }           
  86          
  87          
  88          //W25Qxx写禁止  
  89          //将WEL清零  
  90          void W25Qxx_Write_Disable(void)   
  91          {  
  92   1        W25Qxx_CS=0;                            //使能器件   
  93   1          W25Qxx_Write_Byte(W25X_WriteDisable);     //发送写禁止指令    
  94   1        W25Qxx_CS=1;                            //取消片选            
  95   1      } 
  96          
  97          /**************************************************
  98          **函数功能：在指定地址开始读取指定长度的数据
  99          **函数参数：pBuffer:数据存储区
 100                ReadAddr:开始读取的地址(24bit)
 101                NumByteToRead:要读取的字节数(最大65535)
 102          **************************************************/
 103          void W25Qxx_Read(u8* pBuffer,u32 ReadAddr,u16 NumByteToRead)   
 104          { 
 105   1        u16 i;
 106   1        CE=0;
 107   1        W25Qxx_CS=0;                            //使能器件   
 108   1          W25Qxx_Write_Byte(W25X_ReadData);         //发送读取命令   
 109   1          W25Qxx_Write_Byte((u8)((ReadAddr)>>16));  //发送24bit地址    
 110   1          W25Qxx_Write_Byte((u8)((ReadAddr)>>8));   
 111   1          W25Qxx_Write_Byte((u8)ReadAddr);   
 112   1          for(i=0;i<NumByteToRead;i++)
 113   1        { 
 114   2              pBuffer[i] = W25Qxx_Read_Byte();   //循环读数  
 115   2          }
 116   1        W25Qxx_CS=1;                            //取消片选            
C51 COMPILER V9.00   W25QXX                                                                07/13/2015 15:35:09 PAGE 3   

 117   1      }  
 118          
 119          /**************************************************
 120          **函数功能：初始化字库
 121          **返回值：0：字库完好.  1:字库丢失
 122          **************************************************/
 123          u8 font_init(void)
 124          {                                
 125   1        W25Qxx_Write_Disable(); //禁止写   
 126   1        W25Qxx_TYPE = W25Qxx_ReadID();      //读取FLASH ID.  
 127   1        if(ftinfo.fontok!=0XAA)return 1;    //字库错误. 
 128   1        W25Qxx_CS=1;
 129   1        return 0;       
 130   1      }
 131          
 132          
 133          /**************************************************
 134          **函数功能：从字库中查找出字模
 135          **函数参数：code 字符串的开始地址,GBK码,mat:数据存放地址 size :大小  
 136          **************************************************/
 137          void Get_HzMat(unsigned char *gbcode,unsigned char *mat,u8 gbsize)
 138          {       
 139   1        unsigned char qh,ql;
 140   1        unsigned char i;            
 141   1        u32 foffset; 
 142   1        qh=*gbcode;
 143   1        ql=*(++gbcode);
 144   1        if(qh<0x81||ql<0x40||ql==0xff||qh==0xff)//非 常用汉字
 145   1        {  
 146   2            for(i=0;i<(gbsize*2);i++) *mat++=0x00;//填充满格
 147   2            return; //结束访问
 148   2        }          
 149   1        if(ql<0x7f)ql-=0x40;//注意!
 150   1        else ql-=0x41;
 151   1        qh-=0x81;  
 152   1                
 153   1        if(gbsize==32)
 154   1        { 
 155   2          foffset=((unsigned long)190*qh+ql) * 128;//得到字库中的字节偏移量 
 156   2          W25Qxx_Read(mat,foffset+ftinfo.gbk32addr,128);
 157   2        }
 158   1        else if(gbsize==24) 
 159   1        {
 160   2          foffset=((unsigned long)190*qh+ql) * 72;//得到字库中的字节偏移量    
 161   2          W25Qxx_Read(mat,foffset+ftinfo.gbk24addr,72);
 162   2        }
 163   1        else if(gbsize==16) 
 164   1        {
 165   2          foffset=((unsigned long)190*qh+ql)*32;//得到字库中的字节偏移量    
 166   2          W25Qxx_Read(mat,foffset+ftinfo.gbk16addr,32);
 167   2        }
 168   1        else if(gbsize==12) 
 169   1        {
 170   2          foffset=((unsigned long)190*qh+ql)*24;//得到字库中的字节偏移量    
 171   2          W25Qxx_Read(mat,foffset+ftinfo.gbk12addr,24);  
 172   2        }     
 173   1      } 
 174          
 175          /**************************************************
 176          **函数功能：显示一个指定大小的字符
 177          **函数参数：x,y :坐标,num:ASCII码,size:字体大小
 178                p_color:点的颜色, b_color：背景颜色  
C51 COMPILER V9.00   W25QXX                                                                07/13/2015 15:35:09 PAGE 4   

 179          **************************************************/
 180          void Show_ASCII(u16 x,u16 y,u8 num,u8 gbsize,u16 p_color,u16 b_color)
 181          {                 
 182   1          u8 temp,t1,t,max_t;
 183   1        u8 mat[65] = "";
 184   1        u16 y0=y;
 185   1        u32 temp_addr;
 186   1        u32 offset = num - ' ';//得到偏移后的值;
 187   1             
 188   1        if(gbsize==32)    
 189   1        {
 190   2          offset *= 64; 
 191   2          max_t = 64;
 192   2          temp_addr = ftinfo.asc32addr;
 193   2        }
 194   1        else if(gbsize==24) 
 195   1        {
 196   2          offset *= 36; 
 197   2          max_t = 36;
 198   2          temp_addr = ftinfo.asc24addr;
 199   2        }
 200   1        else if(gbsize==16) 
 201   1        {
 202   2          offset *= 16; 
 203   2          max_t = 16;
 204   2          temp_addr = ftinfo.asc16addr;
 205   2        }
 206   1        else if(gbsize==12) 
 207   1        {
 208   2          offset *= 12; 
 209   2          max_t = 12;
 210   2          temp_addr = ftinfo.asc12addr;
 211   2        }
 212   1        
 213   1        else if(gbsize==8)  
 214   1        {
 215   2          offset *= 6;  
 216   2          max_t = 6;
 217   2          temp_addr = ftinfo.asc68addr;
 218   2        }
 219   1        
 220   1        W25Qxx_Read(mat,offset + temp_addr,max_t);
 221   1        
 222   1        for(t=0;t<max_t;t++)
 223   1        {   
 224   2          temp=mat[t];  //调用字体数组
 225   2          for(t1=0;t1<8;t1++)
 226   2          {   
 227   3            if(gbsize==8)
 228   3            {
 229   4              if((temp >> t1) & 0x01)
 230   4                SHOW_POINT_FUNC(x,y,p_color);//在指定位置打指定颜色的点
 231   4              else 
 232   4                if(b_color!=Nocolor) if(b_color!=Nocolor) SHOW_POINT_FUNC(x,y,b_color);//在指定位置打指定颜色的点
 233   4            } 
 234   3            else
 235   3            {
 236   4              if((temp << t1) & 0x80)
 237   4                SHOW_POINT_FUNC(x,y,p_color);//在指定位置打指定颜色的点
 238   4              else 
 239   4                if(b_color!=Nocolor) SHOW_POINT_FUNC(x,y,b_color);//在指定位置打指定颜色的点
 240   4            }
C51 COMPILER V9.00   W25QXX                                                                07/13/2015 15:35:09 PAGE 5   

 241   3            
 242   3            y++;
 243   3            if(y >= max_y){return;}//超区域了
 244   3            
 245   3            if((y-y0)==gbsize)
 246   3            {
 247   4              y=y0;
 248   4              x++;
 249   4              if(x >= max_x){return;}//超区域了
 250   4              break;
 251   4            }
 252   3          }    
 253   2        }                   
 254   1      }
 255          
 256          
 257          /**************************************************
 258          **函数功能：显示一个指定大小的汉字
 259          **函数参数：x,y :汉字的坐标,font:汉字GBK码,size:字体大小
 260                  p_color:点的颜色, b_color：背景颜色
 261          **************************************************/
 262          void Show_Font(u16 x,u16 y,u8 *font,u8 gbsize,u16 p_color,u16 b_color)
 263          {
 264   1        u16 temp,t,t1,max_t;
 265   1        u16 y0=y;
 266   1        u8 dzk[256]; 
 267   1        if(gbsize!=12 && gbsize!=16 && gbsize!=24 && gbsize!= 32)
 268   1          return;//不支持的size
 269   1        
 270   1        Get_HzMat(font,dzk,gbsize);//得到相应大小的点阵数据
 271   1        
 272   1        if(gbsize == 32)      max_t = 128;
 273   1        else if(gbsize == 24) max_t = 72;
 274   1        else        max_t = gbsize * 2;
 275   1        
 276   1       
 277   1        for(t = 0;t < max_t;t++)
 278   1        {                              
 279   2          temp=dzk[t];                         
 280   2          for(t1=0;t1<8;t1++)
 281   2          {
 282   3            if(temp&0x80)
 283   3            {
 284   4              SHOW_POINT_FUNC(x,y,p_color);//在指定位置打指定颜色的点
 285   4            }
 286   3            else 
 287   3            {
 288   4              if(b_color!=Nocolor) SHOW_POINT_FUNC(x,y,b_color);//在指定位置打指定颜色的点
 289   4            }
 290   3            
 291   3            temp<<=1;
 292   3            y++;
 293   3            if((y-y0)==gbsize)
 294   3            {
 295   4              y=y0;
 296   4              x++;
 297   4              break;
 298   4            }
 299   3          }    
 300   2        } 
 301   1      }
 302          
C51 COMPILER V9.00   W25QXX                                                                07/13/2015 15:35:09 PAGE 6   

 303          
 304          /*********************************************************************
 305          **函数功能：在指定位置开始显示一个字符串    
 306          **函数参数：(x,y):起始坐标，str  :字符串，size :字体大小，
 307                p_color:点的颜色, b_color：背景颜色
 308          **********************************************************************/
 309          void Show_Str(u16 x,u16 y,u8 *str,u8 gbsize,u16 p_color,u16 b_color)
 310          {                     
 311   1          u8 bHz=0;     //字符或者中文  
 312   1          while(*str!=0)//数据未结束
 313   1          { 
 314   2              if(!bHz)
 315   2              {
 316   3                if(*str > 0x80)
 317   3              bHz=1;//中文 
 318   3                else              //字符
 319   3                {         
 320   4              if(y > max_y)break;//越界返回 
 321   4              Show_ASCII(x,y,*str,gbsize,p_color,b_color);//有效部分写入 
 322   4              str++; 
 323   4              
 324   4                  if(gbsize == 8)
 325   4                x += 6; //字符,为全字的一半 
 326   4              else  
 327   4                x += gbsize/2; //字符,为全字的一半 
 328   4                
 329   4              if(x > max_x)//换行
 330   4              { 
 331   5                str -= 1; 
 332   5                y += gbsize;
 333   5                x = 0;     
 334   5              }
 335   4                }
 336   3              }
 337   2          else//中文 
 338   2              {     
 339   3                  bHz=0;//有汉字库 
 340   3      
 341   3                if(y > max_y)break;//越界返回   
 342   3            
 343   3                Show_Font(x,y,str,gbsize,p_color,b_color); //显示这个汉字,空心显示 
 344   3                str+=2; 
 345   3                x += gbsize;//下一个汉字偏移
 346   3            
 347   3            if(x > max_x)//换行
 348   3            { 
 349   4              str -= 2; 
 350   4              y += gbsize;
 351   4              x = 0;     
 352   4            }     
 353   3              }            
 354   2          }   
 355   1      }  
 356          
 357          /*********************************************************************
 358          **函数功能：在指定位置开始显示数字    
 359          **函数参数：(x,y):起始坐标，num :数字，len:数字的位数，size :字体大小，
 360                p_color:点的颜色, b_color：背景颜色
 361          **********************************************************************/
 362          /*void Show_number(u16 x,u16 y,u32 num,u8 len,u8 gbsize,u16 p_color,u16 b_color)
 363          { 
 364            u8 buf[10] = "";
C51 COMPILER V9.00   W25QXX                                                                07/13/2015 15:35:09 PAGE 7   

 365            u32 t_num = 1;
 366            u8 i;
 367            for(i = 0; i < len; i++)
 368            {
 369              buf[len - i - 1] = num / t_num % 10 + '0';
 370              t_num *= 10;
 371            }
 372              
 373            Show_Str(x,y,buf,gbsize,p_color,b_color);
 374              
 375          }*/
 376          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2346    ----
   CONSTANT SIZE    =    141    ----
   XDATA SIZE       =      2     407
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
