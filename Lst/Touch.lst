C51 COMPILER V9.00   TOUCH                                                                 06/22/2015 11:49:33 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE TOUCH
OBJECT MODULE PLACED IN .\Object\Touch.obj
COMPILER INVOKED BY: d:\Keil\C51\BIN\C51.EXE user\TOUCH\Touch.c LARGE BROWSE INCDIR(.\user\LCD;.\user\W25Qxx;.\user;.\us
                    -er\TOUCH;.\user\flash;.\user\ds1302;.\user\timer;.\user\GUI;.\user\ds18b20;.\user\uart;.\user\ATCmd;.\user\led) DEBUG OB
                    -JECTEXTEND PRINT(.\Lst\Touch.lst) OBJECT(.\Object\Touch.obj)

line level    source

   1          #include "Touch.h"
   2          #include "stdlib.h"
   3          #include "math.h"       
   4          #include "stdio.h"
   5          
   6          
   7          _m_tp_dev tp_dev=
   8          {
   9                  TP_Init,
  10                  TP_Scan,
  11                  TP_Adjust,
  12                  0,
  13                  0,
  14                  0,
  15                  0,
  16                  0,
  17                  0,
  18                  0,
  19                  0,                              
  20                  0,
  21                  0,                              
  22          };      
  23          
  24          
  25          //默认为touchtype=0的数据.
  26          u8 CMD_RDX=0XD0;
  27          u8 CMD_RDY=0X90;
  28          
  29          
  30          
  31          static void delay_us(u16 us)    
  32          { 
  33   1              uint16_t i; 
  34   1              us *= 8;
  35   1              for( i = 0; i < us; i++ );
  36   1      } 
  37          
  38          
  39          //SPI写数据
  40          //向触摸屏IC写入1byte数据    
  41          //num:要写入的数据
  42          void TP_Write_Byte(u8 num)    
  43          {  
  44   1              u8 count=0;   
  45   1              for(count=0;count<8;count++)  
  46   1              {         
  47   2                      if(num&0x80)TDIN=1;  
  48   2                      else TDIN=0;   
  49   2                      num<<=1;    
  50   2                      TCLK=0;          
  51   2                      TCLK=1;         //上升沿有效            
  52   2              }                                           
  53   1      }       
C51 COMPILER V9.00   TOUCH                                                                 06/22/2015 11:49:33 PAGE 2   

  54          
  55          
  56          //SPI读数据 
  57          //从触摸屏IC读取adc值
  58          //CMD:指令
  59          //返回值:读到的数据        
  60          u16 TP_Read_AD(u8 CMD)    
  61          {        
  62   1              u8 count=0;       
  63   1              u16 Num=0; 
  64   1              TCLK=0;         //先拉低时钟     
  65   1              TDIN=0;         //拉低数据线
  66   1              TCS=0;          //选中触摸屏IC
  67   1              TP_Write_Byte(CMD);//发送命令字
  68   1              delay_us(6);//ADS7846的转换时间最长为6us
  69   1              TCLK=0;                     
  70   1              delay_us(1);               
  71   1              TCLK=1;         //给1个时钟，清除BUSY               
  72   1              TCLK=0;                     
  73   1              for(count=0;count<16;count++)//读出16位数据,只有高12位有效 
  74   1              {                                 
  75   2                      Num<<=1;         
  76   2                      TCLK=0; //下降沿有效               
  77   2                      TCLK=1;
  78   2                      if(DOUT)Num++;           
  79   2              }       
  80   1              Num>>=4;        //只有高12位有效.
  81   1              TCS=1;          //释放片选       
  82   1              return(Num);   
  83   1      }
  84          
  85          
  86          //读取一个坐标值(x或者y)
  87          //连续读取READ_TIMES次数据,对这些数据升序排列,
  88          //然后去掉最低和最高LOST_VAL个数,取平均值 
  89          //xy:指令（CMD_RDX/CMD_RDY）
  90          //返回值:读到的数据
  91          #define READ_TIMES 5    //读取次数
  92          #define LOST_VAL 1              //丢弃值
  93          u16 TP_Read_XOY(u8 xy)
  94          {
  95   1              u16 i, j;
  96   1              u16 buf[READ_TIMES];
  97   1              u16 sum=0;
  98   1              u16 temp;
  99   1              for(i=0;i<READ_TIMES;i++)buf[i]=TP_Read_AD(xy);                             
 100   1              for(i=0;i<READ_TIMES-1; i++)//排序
 101   1              {
 102   2                      for(j=i+1;j<READ_TIMES;j++)
 103   2                      {
 104   3                              if(buf[i]>buf[j])//升序排列
 105   3                              {
 106   4                                      temp=buf[i];
 107   4                                      buf[i]=buf[j];
 108   4                                      buf[j]=temp;
 109   4                              }
 110   3                      }
 111   2              }         
 112   1              sum=0;
 113   1              for(i=LOST_VAL;i<READ_TIMES-LOST_VAL;i++)sum+=buf[i];
 114   1              temp=sum/(READ_TIMES-2*LOST_VAL);
 115   1              return temp;   
C51 COMPILER V9.00   TOUCH                                                                 06/22/2015 11:49:33 PAGE 3   

 116   1      } 
 117          //读取x,y坐标
 118          //最小值不能少于100.
 119          //x,y:读取到的坐标值
 120          //返回值:0,失败;1,成功。
 121          u8 TP_Read_XY(u16 *x,u16 *y)
 122          {
 123   1              u16 xtemp,ytemp;                                                  
 124   1              xtemp=TP_Read_XOY(CMD_RDX);
 125   1              ytemp=TP_Read_XOY(CMD_RDY);                                                                                                        
 126   1      //      if(xtemp<100||ytemp<100)return 0;//读数失败
 127   1              *x=xtemp;
 128   1              *y=ytemp;
 129   1              return 1;//读数成功
 130   1      }
 131          //连续2次读取触摸屏IC,且这两次的偏差不能超过
 132          //ERR_RANGE,满足条件,则认为读数正确,否则读数错误.          
 133          //该函数能大大提高准确度
 134          //x,y:读取到的坐标值
 135          //返回值:0,失败;1,成功。
 136          #define ERR_RANGE 50 //误差范围 
 137          u8 TP_Read_XY2(u16 *x,u16 *y) 
 138          {
 139   1              u16 x1,y1;
 140   1              u16 x2,y2;
 141   1              u8 flag;    
 142   1              flag=TP_Read_XY(&x1,&y1);   
 143   1              if(flag==0)return(0);
 144   1              flag=TP_Read_XY(&x2,&y2);          
 145   1              if(flag==0)return(0);   
 146   1              if(((x2<=x1&&x1<x2+ERR_RANGE)||(x1<=x2&&x2<x1+ERR_RANGE))//前后两次采样在+-50内
 147   1              &&((y2<=y1&&y1<y2+ERR_RANGE)||(y1<=y2&&y2<y1+ERR_RANGE)))
 148   1              {
 149   2                              *x=(x1+x2)/2;
 150   2                              *y=(y1+y2)/2;   
 151   2                              return 1;
 152   2              }else return 0;   
 153   1      } 
 154          
 155          //////////////////////////////////////////////////////////////////////////////////                
 156          //与LCD部分有关的函数  
 157          //画一个触摸点
 158          //用来校准用的
 159          //x,y:坐标
 160          //color:颜色
 161          void TP_Drow_Touch_Point(u16 x,u16 y,u16 color)
 162          {
 163   1              LCD_DrawLine(x-12,y,x+13,y,color);//横线
 164   1              LCD_DrawLine(x,y-12,x,y+13,color);//竖线
 165   1              LCD_SetPoint(x+1,y+1,color);
 166   1              LCD_SetPoint(x-1,y+1,color);
 167   1              LCD_SetPoint(x+1,y-1,color);
 168   1              LCD_SetPoint(x-1,y-1,color);
 169   1      }         
 170          //画一个大点(2*2的点)              
 171          //x,y:坐标
 172          //color:颜色
 173          void TP_Draw_Big_Point(u16 x,u16 y,u16 color)
 174          {       
 175   1              LCD_SetPoint(x,y,color);//中心点 
 176   1              LCD_SetPoint(x+1,y,color);
 177   1              LCD_SetPoint(x,y+1,color);
C51 COMPILER V9.00   TOUCH                                                                 06/22/2015 11:49:33 PAGE 4   

 178   1              LCD_SetPoint(x+1,y+1,color);                    
 179   1      }
 180          
 181          //////////////////////////////////////////////////////////////////////////////////                
 182          //触摸按键扫描
 183          //tp:0,屏幕坐标;1,物理坐标(校准等特殊场合用)
 184          //返回值:当前触屏状态.
 185          //0,触屏无触摸;1,触屏有触摸
 186          u8 TP_Scan(u8 tp)
 187          {                          
 188   1              if(PEN==0)//有按键按下
 189   1              {
 190   2                      if(tp)TP_Read_XY2(&tp_dev.x,&tp_dev.y);//读取物理坐标
 191   2                      else if(TP_Read_XY2(&tp_dev.x,&tp_dev.y))//读取屏幕坐标
 192   2                      {
 193   3                              tp_dev.x=tp_dev.xfac*tp_dev.x+tp_dev.xoff;//将结果转换为屏幕坐标
 194   3                              tp_dev.y=tp_dev.yfac*tp_dev.y+tp_dev.yoff;  
 195   3                      } 
 196   2                      if((tp_dev.sta&TP_PRES_DOWN)==0)//之前没有被按下
 197   2                      {                
 198   3                              tp_dev.sta=TP_PRES_DOWN|TP_CATH_PRES;//按键按下  
 199   3                              tp_dev.x0=tp_dev.x;//记录第一次按下时的坐标
 200   3                              tp_dev.y0=tp_dev.y;                              
 201   3                      }                          
 202   2              }else
 203   1              {
 204   2                      if(tp_dev.sta&TP_PRES_DOWN)//之前是被按下的
 205   2                      {
 206   3                              tp_dev.sta&=~(1<<7);//标记按键松开      
 207   3                      }else//之前就没有被按下
 208   2                      {
 209   3                              tp_dev.x0=0;
 210   3                              tp_dev.y0=0;
 211   3                              tp_dev.x=0xffff;
 212   3                              tp_dev.y=0xffff;
 213   3                      }           
 214   2              }
 215   1              return tp_dev.sta&TP_PRES_DOWN;//返回当前的触屏状态
 216   1      }         
 217          
 218          
 219          //触摸屏校准代码
 220          //得到四个校准参数
 221          void TP_Adjust(void)
 222          {                                                                
 223   1              u16 pos_temp[4][2];//坐标缓存值
 224   1              u8  cnt=0;      
 225   1              u16 d1,d2;
 226   1              u32 tem1,tem2;
 227   1              float fac;      
 228   1              cnt=0;                                  
 229   1              LCD_Clear(White);//清屏   
 230   1      
 231   1              TP_Drow_Touch_Point(60,60,Red);//画点1 
 232   1              tp_dev.sta=0;//消除触发信号 
 233   1              tp_dev.xfac=0;//xfac用来标记是否校准过,所以校准之前必须清掉!以免错误     
 234   1              while(1)//如果连续10秒钟没有按下,则自动退出
 235   1              {
 236   2                      tp_dev.scan(1);//扫描物理坐标
 237   2                      if((tp_dev.sta&0xc0)==TP_CATH_PRES)//按键按下了一次(此时按键松开了.)
 238   2                      {       
 239   3                              tp_dev.sta&=~(1<<6);//标记按键已经被处理过了.                                              
C51 COMPILER V9.00   TOUCH                                                                 06/22/2015 11:49:33 PAGE 5   

 240   3                              pos_temp[cnt][0]=tp_dev.x;
 241   3                              pos_temp[cnt][1]=tp_dev.y;
 242   3                              cnt++;    
 243   3                              switch(cnt)
 244   3                              {                          
 245   4                                      case 1:                                          
 246   4                                              TP_Drow_Touch_Point(60,60,White);                               //清除点1 
 247   4                                              TP_Drow_Touch_Point(260,60,Red);        //画点2
 248   4                                              break;
 249   4                                      case 2:
 250   4                                              TP_Drow_Touch_Point(260,60,White);      //清除点2
 251   4                                              TP_Drow_Touch_Point(60,260,Red);        //画点3
 252   4                                              break;
 253   4                                      case 3:
 254   4                                              TP_Drow_Touch_Point(60,260,White);                      //清除点3
 255   4                                              TP_Drow_Touch_Point(260,260,Red);       //画点4
 256   4                                              break;
 257   4                                      case 4:  //全部四个点已经得到
 258   4                                  //对边相等
 259   4                                              tem1=abs(pos_temp[0][0]-pos_temp[1][0]);//x1-x2
 260   4                                              tem2=abs(pos_temp[0][1]-pos_temp[1][1]);//y1-y2
 261   4                                              tem1*=tem1;
 262   4                                              tem2*=tem2;
 263   4                                              d1=sqrt(tem1+tem2);//得到1,2的距离
 264   4                                              
 265   4                                              tem1=abs(pos_temp[2][0]-pos_temp[3][0]);//x3-x4
 266   4                                              tem2=abs(pos_temp[2][1]-pos_temp[3][1]);//y3-y4
 267   4                                              tem1*=tem1;
 268   4                                              tem2*=tem2;
 269   4                                              d2=sqrt(tem1+tem2);//得到3,4的距离
 270   4                                              fac=(float)d1/d2;
 271   4                                              if(fac<0.95||fac>1.05||d1==0||d2==0)//不合格
 272   4                                              {
 273   5                                                      cnt=0;
 274   5                                          TP_Drow_Touch_Point(260,260,White); //清除点4
 275   5                                              TP_Drow_Touch_Point(60,60,Red);                                                         //画点1 
 276   5                                                      continue;
 277   5                                              }
 278   4                                              tem1=abs(pos_temp[0][0]-pos_temp[2][0]);//x1-x3
 279   4                                              tem2=abs(pos_temp[0][1]-pos_temp[2][1]);//y1-y3
 280   4                                              tem1*=tem1;
 281   4                                              tem2*=tem2;
 282   4                                              d1=sqrt(tem1+tem2);//得到1,3的距离
 283   4                                              
 284   4                                              tem1=abs(pos_temp[1][0]-pos_temp[3][0]);//x2-x4
 285   4                                              tem2=abs(pos_temp[1][1]-pos_temp[3][1]);//y2-y4
 286   4                                              tem1*=tem1;
 287   4                                              tem2*=tem2;
 288   4                                              d2=sqrt(tem1+tem2);//得到2,4的距离
 289   4                                              fac=(float)d1/d2;
 290   4                                              if(fac<0.95||fac>1.05)//不合格
 291   4                                              {
 292   5                                                      cnt=0;
 293   5                                          TP_Drow_Touch_Point(260,260,White); //清除点4
 294   5                                              TP_Drow_Touch_Point(60,60,Red);                                                         //画点1
 295   5                                                      continue;
 296   5                                              }//正确了                                          
 297   4                                              //对角线相等
 298   4                                              tem1=abs(pos_temp[1][0]-pos_temp[2][0]);//x1-x3
 299   4                                              tem2=abs(pos_temp[1][1]-pos_temp[2][1]);//y1-y3
 300   4                                              tem1*=tem1;
 301   4                                              tem2*=tem2;
C51 COMPILER V9.00   TOUCH                                                                 06/22/2015 11:49:33 PAGE 6   

 302   4                                              d1=sqrt(tem1+tem2);//得到1,4的距离
 303   4              
 304   4                                              tem1=abs(pos_temp[0][0]-pos_temp[3][0]);//x2-x4
 305   4                                              tem2=abs(pos_temp[0][1]-pos_temp[3][1]);//y2-y4
 306   4                                              tem1*=tem1;
 307   4                                              tem2*=tem2;
 308   4                                              d2=sqrt(tem1+tem2);//得到2,3的距离
 309   4                                              fac=(float)d1/d2;
 310   4                                              if(fac<0.95||fac>1.05)//不合格
 311   4                                              {
 312   5                                                      cnt=0;
 313   5                                          TP_Drow_Touch_Point(260,260,White); //清除点4
 314   5                                              TP_Drow_Touch_Point(60,60,Red);                                                         //画点1
 315   5                                                      continue;
 316   5                                              }//正确了
 317   4                                              //计算结果
 318   4                                              tp_dev.xfac=(float)200.0/(pos_temp[1][0]-pos_temp[0][0]);//得到xfac              
 319   4                                              tp_dev.xoff=(320.0-tp_dev.xfac*(pos_temp[1][0]+pos_temp[0][0]))/2;//得到xoff
 320   4                                                        
 321   4                                              tp_dev.yfac=(float)200.0/(pos_temp[2][1]-pos_temp[0][1]);//得到yfac
 322   4                                              tp_dev.yoff=(320.0-tp_dev.yfac*(pos_temp[2][1]+pos_temp[0][1]))/2;//得到yoff  
 323   4                                              if(abs(tp_dev.xfac)>2||abs(tp_dev.yfac)>2)//触屏和预设的相反了.
 324   4                                              {
 325   5                                                      cnt=0;
 326   5                                                      TP_Drow_Touch_Point(260,260,White);                                             //清除点4
 327   5                                                      TP_Drow_Touch_Point(60,60,Red);                                         //画点1
 328   5                                                      tp_dev.touchtype=!tp_dev.touchtype;//修改触屏类型.
 329   5                                                      if(tp_dev.touchtype)//X,Y方向与屏幕相反
 330   5                                                      {
 331   6                                                              CMD_RDX=0X90;
 332   6                                                              CMD_RDY=0XD0;    
 333   6                                                      }else                              //X,Y方向与屏幕相同
 334   5                                                      {
 335   6                                                              CMD_RDX=0XD0;
 336   6                                                              CMD_RDY=0X90;    
 337   6                                                      }                           
 338   5                                                      continue;
 339   5                                              }               
 340   4                                              LCD_Clear(White);//清屏
 341   4      //                                      LCD_ShowString(60,120,"Adjust OK!",16,Red);//校正完成
 342   4                                              delay_ms(1000);
 343   4                                              LCD_Clear(White);//清屏   
 344   4                                              return;//校正完成                                
 345   4                              }
 346   3                      }
 347   2              }
 348   1      }
 349          
 350          //存储一些校正好的数据，不必每次手动校正
 351          void TP_Default_Adj(void)
 352          {
 353   1      //              if(lcddev.dir==0)   //竖屏
 354   1      //              {
 355   1      //                      CMD_RDX=0XD0;
 356   1      //                      CMD_RDY=0X90;    
 357   1      //                      tp_dev.xoff=332;
 358   1      //                      tp_dev.xfac=-0.084962;
 359   1      //                      tp_dev.yoff=508;
 360   1      //                      tp_dev.yfac=-0.130634;
 361   1      //              }else                                                           //横屏
 362   1      //              {
 363   1                              CMD_RDX=0X90;
C51 COMPILER V9.00   TOUCH                                                                 06/22/2015 11:49:33 PAGE 7   

 364   1                              CMD_RDY=0XD0;   
 365   1                              tp_dev.xoff=-12;
 366   1                              tp_dev.xfac=0.121803;
 367   1                              tp_dev.yoff=330;
 368   1                              tp_dev.yfac=-0.083472;
 369   1      //              }
 370   1      }
 371          //触摸屏初始化                      
 372          u8 TP_Init(void)
 373          {                                          
 374   1       
 375   1              TP_Read_XY(&tp_dev.x,&tp_dev.y);//第一次读取初始化                                                                                  
 376   1      //      TP_Adjust();  //屏幕校准 
 377   1              TP_Default_Adj();
 378   1              return 1;                                                                        
 379   1      }
 380          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3883    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     33      83
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
